---
title: "LeetCode-9. Palindrome Number"
layout: post
date: 2019-03-24 23:02
image: 
headerImage: false
tag:
- Algorithm
- LeetCode
category: blog
author: NoThxJ
description: LeetCode
---

#### Description

------

Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

**Example 1:**

```
Input: 121
Output: true
```

**Example 2:**

```
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
```

**Example 3:**

```
Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
```

**Follow up:**

Coud you solve it without converting the integer to a string?

这道验证回文数字的题，如果将数字转为字符串，就变成了验证回文字符串的题；直接做 Follow up，不能转为字符串，而是直接对整数进行操作，可以利用取整和取余来获得想要的数字

- 解法1

  ```c++
  class Solution {
  public:
      bool isPalindrome(int x) {
          if(x < 0)
              return false;
          int div = 1;
          while(x / div >= 10)
              div *= 10;
          while(x > 0){
              int left = x / div;
              int right = x % 10;
              if(left != right)
                  return false;
              x = (x % div) / 10;
              div /= 100;
          }
          
          return true;
      }
  };
  ```

- 解法2

  ```c++
  // 巧妙解法，首先判断x是否为负数，这里用一个小技巧，因为整数的最高位不能是0，所以回文数的最低位也不能为0，数字0除外，所以如果发现某个正数的末尾是0，直接返回false即可。具体解法，要验证回文数，那么就需要看前后半段是否对称，如果把后半段翻转一下，就看和前半段是否相等就行了。做法就是取出后半段数字，进行翻转，每次通过对10取余，取出最低位的数字，然后加到取出数的末尾，就是将revertNum乘以10，再加上这个余数，这样翻转也就同时完成了，每取一个最低位数字，x都要自除以10.这样当revertNum大于等于x的时候循环停止。由于回文数的位数可奇可偶，如果是偶数，那么revertNum和x相等；如果是奇数，那么最中间的数字就在revertNum的最低位上了，除以10以后应该和x是相等的
  
  class Solution {
  public:
      bool isPalindrome(int x) {
          if(x < 0 || (x % 10 == 0 && x != 0))
              return false;
          int revertNum = 0;
          while(x > revertNum){
              revertNum = revertNum * 10 + x % 10;
              x /= 10;
          }
          
          return x == revertNum || x == revertNum / 10;
      }
  };
  ```

- 解法3

  ```c++
  // 如果是palindrome，反转后仍是原数字，就不可能溢出，只要溢出一定不是alindrome，返回false就行
  
  class Solution {
  public:
      bool isPalindrome(int x) {
          if(x < 0 || (x % 10 == 0 && x != 0))
              return false;
          return reverse(x) == x;
      }
      
      int reverse(int x){
          int res = 0;
          while(x != 0){
              if(res > INT_MAX / 10)
                  return -1;
              res = res * 10 + x % 10;
              x /= 10;
          }
          return res;
      }
  };
  ```
